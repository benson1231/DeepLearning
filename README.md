# 基本線性代數

## 張量的基本結構
### 標量（Scalars)
- 單一的數值，只有一個數據點。
- **維度（Rank）**: 0
- **例子**: \( 3, -1, \pi \)

### 向量（Vectors）
- 一維的數據結構，可以包含多個數值。
- **維度（Rank）**: 1
- **例子**: \( [1, 2, 3] \), \( [-5, 0, 8] \)

### 矩陣（Matrices）
- 二維的數據結構，由行（rows）和列（columns）組成。
- **維度（Rank）**: 2
- **例子**:
  \[
  \begin{bmatrix}
  1 & 2 & 3 \\
  4 & 5 & 6
  \end{bmatrix}
  \]

### 高維張量（Higher-order Tensors）
- 超過二維的多維陣列。
- **維度（Rank）**: 3 或更高
- **例子**: 用於表示圖片資料的四維張量，形狀為 \( [批次大小, 高度, 寬度, 通道數] \)。

## 張量與代數運算

張量支持多種運算，包括但不限於：
- **加法**: \( A + B \)
- **內積**: \( A \cdot B \)
- **轉置**: \( A^T \)
- **廣播（Broadcasting）**: 自動對齊不同形狀的張量。

## 張量的表示

在 Python 中，我們通常使用 **NumPy** 或 **TensorFlow/PyTorch** 來操作張量。例如：

```python
import tensorflow as tf

# 創建一個二維張量
matrix = tf.constant([[1, 2, 3], [4, 5, 6]])
print(matrix.shape)  # 輸出: (2, 3)
```
---

# 常見的隱藏層激活函數

在神經網絡中，激活函數用於引入非線性，使模型能學習複雜的數據模式。

## 1. ReLU（Rectified Linear Unit）
- **公式**: \( f(x) = \max(0, x) \)
- **範圍**: \( [0, \infty) \)
- **優點**:
  - 計算效率高。
  - 避免梯度消失問題。
- **缺點**:
  - 可能導致神經元死亡。
- **用途**: 最常用的隱藏層激活函數。

## 2. Leaky ReLU
- **公式**:
  \[
  f(x) =
  \begin{cases}
  x, & x > 0 \\
  \alpha x, & x \leq 0
  \end{cases}
  \]
  (\( \alpha > 0 \))
- **範圍**: \( (-\infty, \infty) \)
- **優點**: 解決 ReLU 的神經元死亡問題。
- **用途**: 深層模型或數據分布不均時。

## 3. Sigmoid
- **公式**: \( f(x) = \frac{1}{1 + e^{-x}} \)
- **範圍**: \( (0, 1) \)
- **優點**:
  - 將輸出壓縮到 \( (0, 1) \)，類似概率。
- **缺點**:
  - 容易導致梯度消失。
- **用途**: 很少用於隱藏層，多用於輸出層。

## 4. Tanh（Hyperbolic Tangent）
- **公式**: \( f(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}} \)
- **範圍**: \( (-1, 1) \)
- **優點**:
  - 比 Sigmoid 更適合隱藏層。
- **缺點**:
  - 容易遇到梯度消失問題。
- **用途**: 特殊情況下用於隱藏層。

## 5. Softplus
- **公式**: \( f(x) = \ln(1 + e^x) \)
- **範圍**: \( (0, \infty) \)
- **優點**: 是 ReLU 的平滑版本。
- **缺點**: 計算效率較低。
- **用途**: 需要平滑激活的場景。

## 6. ELU（Exponential Linear Unit）
- **公式**:
  \[
  f(x) =
  \begin{cases}
  x, & x > 0 \\
  \alpha(e^x - 1), & x \leq 0
  \end{cases}
  \]
- **範圍**: \( (-\alpha, \infty) \)
- **優點**:
  - 解決 ReLU 對負值的問題。
- **用途**: 需要更高穩定性時。

## 7. Swish
- **公式**: \( f(x) = x \cdot \text{sigmoid}(x) \)
- **範圍**: \( (-\infty, \infty) \)
- **優點**: 性能優異，曲線平滑。
- **用途**: 高性能深度學習應用。

## 總結
| 激活函數 | 範圍 | 優點 | 缺點 | 使用場景 |
| -------- | ---- | ---- | ---- | -------- |
| ReLU | \( [0, \infty) \) | 計算高效，梯度非零 | 神經元死亡問題 | 最通用 |
| Leaky ReLU | \( (-\infty, \infty) \) | 避免死亡問題 | 較少用於特殊場合 | 替代 ReLU |
| Sigmoid | \( (0, 1) \) | 類似概率 | 梯度消失 | 輸出層 |
| Tanh | \( (-1, 1) \) | 較適合隱藏層 | 梯度消失 | 特殊隱藏層 |
| Softplus | \( (0, \infty) \) | 平滑 ReLU | 計算較慢 | 平滑需求 |
| ELU | \( (-\alpha, \infty) \) | 負值穩定 | 速度稍慢 | 穩定需求 |
| Swish | \( (-\infty, \infty) \) | 平滑，性能強 | 較新，理解難 | 高性能應用 |

# 損失函數介紹

損失函數是機器學習模型中用於衡量預測結果與實際目標之間差距的指標。以下介紹兩種常見的損失函數及其應用場景。

## 1. 均方誤差（Mean Squared Error, MSE）

### **應用場景**
均方誤差通常用於 **線性迴歸** 或其他回歸問題中。它通過計算預測值與實際值之間的平方差來衡量模型的性能。

### **公式**
\[
\text{MSE} = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2
\]
- \( y_i \): 實際值
- \( \hat{y}_i \): 預測值
- \( n \): 樣本數

### **計算過程**
1. 計算每個數據點的預測值與實際值之間的差異。
2. 將每個差異平方。
3. 計算所有平方差的平均值。

### **視覺化**
假設有一條 **最佳擬合線**，均方誤差會顯示每個數據點到該線的 **平方距離**。這些平方距離越小，模型擬合效果越好。

## 2. 交叉熵損失（Cross-Entropy Loss）

### **應用場景**
交叉熵損失主要用於 **分類問題**，尤其是多類分類模型，例如 **神經網絡中的分類學習模型**。

### **公式**
對於二元分類：
\[
\text{Cross-Entropy Loss} = - \frac{1}{n} \sum_{i=1}^{n} \left[ y_i \log(\hat{y}_i) + (1 - y_i) \log(1 - \hat{y}_i) \right]
\]
- \( y_i \): 實際類別（0 或 1）
- \( \hat{y}_i \): 預測類別的概率
- \( n \): 樣本數

對於多類分類：
\[
\text{Cross-Entropy Loss} = - \sum_{i=1}^{n} \sum_{j=1}^{k} y_{ij} \log(\hat{y}_{ij})
\]
- \( k \): 類別數

### **特點**
- 強調預測值與實際概率分佈的匹配。
- 應用於 **Softmax 激活函數** 的輸出層，對多類分類模型表現良好。

---

## **損失函數對比**

| 損失函數        | 應用場景   | 優勢                  | 劣勢                   |
| ---------------- | ---------- | --------------------- | ---------------------- |
| 均方誤差（MSE） | 回歸問題   | 計算簡單，易於理解    | 對離群值敏感           |
| 交叉熵損失       | 分類問題   | 適用分類，效果穩定    | 需要概率分佈的預測輸出 |

---

透過選擇合適的損失函數，可以更有效地指導模型訓練並提升性能。


```python
from sklearn.metrics import log_loss

ex_1_true = [1, 0, 0]  # 第一類
ex_2_true = [0, 1, 0]  # 第二類
ex_3_true = [0, 0, 1]  # 第三類

ex_1_predicted = [0.7, 0.2, 0.1]  # 準確預測
ex_1_predicted_bad = [0.1, 0.1, 0.7]  # 錯誤預測

ll = log_loss(true_labels, predicted_labels)
print('Average Log Loss (good prediction): %.3f' % ll)

ll = log_loss(true_labels, predicted_labels_bad)
print('Average Log Loss (bad prediction): %.3f' % ll)
```

# 優化算法介紹

在機器學習中，優化算法用於調整模型參數以最小化損失函數。以下介紹三種常見的優化算法：**梯度下降法（GD）**、**隨機梯度下降法（SGD）** 以及 **Adam**。

## 1. 梯度下降法（Gradient Descent, GD）

### **原理**
梯度下降通過計算損失函數相對模型參數的梯度，沿著梯度的反方向更新參數，逐步逼近最優解。

### **公式**
\[
\theta = \theta - \eta \cdot \nabla_{\theta} J(\theta)
\]
- \( \theta \): 模型參數
- \( \eta \): 學習率
- \( \nabla_{\theta} J(\theta) \): 損失函數對參數的梯度

### **特點**
- **優點**: 能穩定收斂到全局最優解（對於凸問題）。
- **缺點**: 每次更新需要使用整個數據集進行計算，計算成本高，特別是對大數據集。

## 2. 隨機梯度下降法（Stochastic Gradient Descent, SGD）

### **原理**
SGD 是梯度下降的一種變體，每次更新使用單個樣本計算梯度，而不是整個數據集。

### **公式**
\[
\theta = \theta - \eta \cdot \nabla_{\theta} J(\theta; x^{(i)}, y^{(i)})
\]
- \( x^{(i)}, y^{(i)} \): 單一樣本及其標籤

### **特點**
- **優點**: 計算效率高，適合大數據集。
- **缺點**: 可能出現梯度波動，導致收斂不穩定。

## 3. Adam（Adaptive Moment Estimation）

### **原理**
Adam 結合了 **動量法** 和 **RMSProp**，通過調整每個參數的學習率，自適應地更新參數。

### **公式**
1. **一階動量（均值）**:
   \[
   m_t = \beta_1 m_{t-1} + (1 - \beta_1) \nabla_{\theta} J(\theta)
   \]
2. **二階動量（方差）**:
   \[
   v_t = \beta_2 v_{t-1} + (1 - \beta_2) (\nabla_{\theta} J(\theta))^2
   \]
3. **參數更新**:
   \[
   \theta = \theta - \eta \cdot \frac{\hat{m}_t}{\sqrt{\hat{v}_t} + \epsilon}
   \]
   - \( \hat{m}_t, \hat{v}_t \): 偏差修正的一階和二階動量
   - \( \epsilon \): 防止分母為零的小常數

### **特點**
- **優點**: 收斂速度快，適合稀疏數據和非平滑目標函數。
- **缺點**: 超參數需要調整，可能過早收斂到次優解。

## **算法對比**

| 優化算法         | 計算效率           | 收斂穩定性      | 適用場景               |
| ---------------- | ------------------ | --------------- | ---------------------- |
| 梯度下降（GD）   | 慢（需整個數據集） | 穩定             | 小型數據集             |
| 隨機梯度下降（SGD） | 快（僅需單個樣本） | 收斂不穩定       | 大型數據集，流式數據   |
| Adam             | 快（自適應學習率） | 收斂穩定，快速   | 稀疏數據，非平滑問題   |

透過選擇適當的優化算法，可以在計算效率與收斂效果間取得平衡，從而提升模型訓練效果。


# 神經網路學習管道概述

## **1. 分類與迴歸任務**

### **分類（Classification）**
- **定義**: 給定資料和每個資料點的真實標籤或類別，訓練模型來預測每個資料範例的標籤。
- **應用案例**:
  - 例如，根據過去火災危險的數據，模型可以學習預測某一天是否可能發生火災。
- **輸出**: 類別標籤（離散值）。

### **迴歸（Regression）**
- **定義**: 給定資料和每個資料點的真實連續值，訓練模型來預測每個資料範例的連續值。
- **應用案例**:
  - 例如，根據先前的股票市場數據，預測特定時間點的股票價格。
- **輸出**: 連續值。

## **2. 神經網路學習的主要組件**

### **2.1 輸入資料**
- **定義**: 訓練神經網路模型所需的資料。
- **作用**: 模型從資料中學習特徵與目標值之間的關係。

### **2.2 優化器（Optimizer）**
- **定義**: 一種演算法，用於根據訓練資料調整網路參數（如權重和偏差）。
- **常見優化器**:
  - **隨機梯度下降（SGD）**
  - **Adam**
  - **RMSprop**

### **2.3 損失函數或成本函數**
- **定義**: 衡量模型在訓練資料上的表現，用於告訴優化器如何改進。
- **常見損失函數**:
  - **分類**: 交叉熵損失（Cross-Entropy Loss）
  - **迴歸**: 均方誤差（Mean Squared Error, MSE）
- **作用**: 損失函數的值越小，模型的預測越接近真實值。

### **2.4 評估指標**
- **定義**: 測量模型在驗證資料上的表現。
- **作用**: 提供模型性能的額外衡量標準，用於選擇最佳模型。
- **常見指標**:
  - **分類**: 準確率（Accuracy）、F1 分數
  - **迴歸**: 平均絕對誤差（Mean Absolute Error, MAE）

## **3. 神經網路參數與學習過程**

- **參數模型**: 神經網路是參數模型，包含權重和偏差等變數。
- **訓練過程**:
  - 使用輸入資料調整參數，使損失函數最小化。
  - 利用優化器找到最佳參數配置。
- **模型評估**:
  - 在訓練期間未見過的測試資料上，評估模型效能。

透過這些組件的協同作用，神經網路可以高效學習並在分類與迴歸問題中進行準確預測。


# 數據預處理步驟概述

## **1. One-hot 編碼**

### **定義**
由於神經網路無法直接處理字串數據，我們需要將分類特徵轉換為數值特徵。One-hot 編碼是常用的技術，為每個類別建立一個二進位列。

### **範例**
假設分類特徵為“區域”，共有四個類別：
- 東北、東南、西北、西南

One-hot 編碼的結果如下：
| 東北 | 西北 | 東南 | 西南 |
|------|------|------|------|
|  1   |  0   |  0   |  0   |
|  0   |  1   |  0   |  0   |

### **實現**
透過 `pandas` 的 `get_dummies()` 函數可完成 One-hot 編碼：
```python
features = pd.get_dummies(features)


```python
from tensorflow.keras.utils import to_categorical

# 原始標籤 (0~9 的數字)
y_train = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 轉換為 one-hot 編碼
y_train_one_hot = to_categorical(y_train, num_classes=10)

print("原始標籤:", y_train)
print("One-hot 編碼:")
print(y_train_one_hot)
```
